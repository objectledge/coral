/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. RelationQueryParser.jj */
/*@egen*/// [x]emacs: fontify this file using java rules -*- java -*-

// 
// Copyright (c) 2003, 2004, Caltha - Gajda, Krzewski, Mach, Potempski Sp.J. 
// All rights reserved. 
//   
// Redistribution and use in source and binary forms, with or without modification,  
// are permitted provided that the following conditions are met: 
//   
// * Redistributions of source code must retain the above copyright notice,  
// this list of conditions and the following disclaimer. 
// * Redistributions in binary form must reproduce the above copyright notice,  
// this list of conditions and the following disclaimer in the documentation  
// and/or other materials provided with the distribution. 
// * Neither the name of the Caltha - Gajda, Krzewski, Mach, Potempski Sp.J.  
// nor the names of its contributors may be used to endorse or promote products  
// derived from this software without specific prior written permission. 
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
// IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  
// POSSIBILITY OF SUCH DAMAGE. 
//

/*
 * examples:
 * 
 * RES('/path/to/resource');
 * RES(12345);
 * 
 * MAP(!'Name of Relation'){ RES('/path/to/resource') };
 * MAPTRANS('Name of Relation'){ RES('/path/to/resource') };
 * 
 * category usage:
 * 
 * MAP('category.References'){ MAPTRANS('coral.ResourceHierarchy'){ RES('/path/to/category') } }
 * +
 * MAP('category.References'){ MAPTRANS('coral.ResourceHierarchy'){ RES('/path/to/category2') } };
 *
 * second example:
 * 
 * MAP('category.References'){ MAPTRANS('coral.ResourceHierarchy'){ RES(1234) } }
 * +
 * MAP('category.References'){ MAPTRANS('coral.ResourceHierarchy'){ RES(3213) } };
 */

options
{
    UNICODE_INPUT = true;
    JAVA_UNICODE_ESCAPE = true;

    CACHE_TOKENS = true;
    OPTIMIZE_TOKEN_MANAGER = true;

    STATIC = false;                                                                   
}

PARSER_BEGIN(RelationQueryParser)

package org.objectledge.coral.relation.query.parser;

import java.io.StringReader;
import java.io.Reader;

/**
 * @author <a href="mailto:dgajda@caltha.pl">Damian Gajda</a>
 */
public class RelationQueryParser/*@bgen(jjtree)*/implements RelationQueryParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTRelationQueryParserState jjtree = new JJTRelationQueryParserState();

/*@egen*/
    public static SimpleNode executeParse(String query)
	throws Exception
    {
	Reader reader = new StringReader(query);
	RelationQueryParser parser = new RelationQueryParser(reader);
	SimpleNode n = parser.Start();
	return n;
    }
}

PARSER_END(RelationQueryParser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

/* Reserved words */
TOKEN:
{
    <SUM : "+"> |
    <INTERSECT : "*">
}

/* Literals */
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER_ID: <NUM> (<NUM>)* >
|
  < IDENTIFIER_PATH: "/" (<LETTER>|<NUM>) (<LETTER>|<NUM>|" "|"/")* >
|
  < IDENTIFIER_NAME: (<LETTER>|<NUM>) (<LETTER>|<NUM>|" ")* >
|
  < #LETTER: ["_", ".", ",", "-",
       "A"-"Z",
       "a"-"z",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff"
      ] >
|
  < #NUM: ["0"-"9"] >
}

SimpleNode Start() :
{/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(this, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/
    SumExpression() ";"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
	return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SumExpression()       :
{}
{/*@bgen(jjtree) #SumExpression(> 1) */
    {
      ASTSumExpression jjtn001 = new ASTSumExpression(this, JJTSUMEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( IntersectionExpression() ( <SUM> IntersectionExpression() )* )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      }
    }
/*@egen*/
}

void IntersectionExpression()       :
{}
{/*@bgen(jjtree) #IntersectionExpression(> 1) */
    {
      ASTIntersectionExpression jjtn001 = new ASTIntersectionExpression(this, JJTINTERSECTIONEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( UnaryExpression() ( <INTERSECT> UnaryExpression() )* )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      }
    }
/*@egen*/
}

void UnaryExpression()       :
{}
{
    "(" SumExpression() ")" | ResourceSetExpression()
}

void ResourceSetExpression()       :
{}
{
    RelationMapExpression() | TransitiveRelationMapExpression() | ResolveExpression()
}

void RelationMapExpression() :
{/*@bgen(jjtree) RelationMapExpression */
  ASTRelationMapExpression jjtn000 = new ASTRelationMapExpression(this, JJTRELATIONMAPEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RelationMapExpression */
    try {
/*@egen*/
    "MAP(" RelationExpression() ")" "{" SumExpression() "}"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void TransitiveRelationMapExpression() :
{/*@bgen(jjtree) TransitiveRelationMapExpression */
  ASTTransitiveRelationMapExpression jjtn000 = new ASTTransitiveRelationMapExpression(this, JJTTRANSITIVERELATIONMAPEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TransitiveRelationMapExpression */
    try {
/*@egen*/
    "MAPTRANS(" RelationExpression() ")" "{" SumExpression() "}"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RelationExpression()       :
{}
{
    InvertedRelationExpression() | RelationIdentifier()
}

void InvertedRelationExpression() :
{/*@bgen(jjtree) InvertedRelationExpression */
  ASTInvertedRelationExpression jjtn000 = new ASTInvertedRelationExpression(this, JJTINVERTEDRELATIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InvertedRelationExpression */
    try {
/*@egen*/
    "!" RelationIdentifier()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RelationIdentifier()       :
{}
{
    "'" RelationName() "'"
}

void RelationName() :
{/*@bgen(jjtree) RelationName */
    ASTRelationName jjtn000 = new ASTRelationName(this, JJTRELATIONNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    ASTRelationName node = (ASTRelationName)jjtn000;
    Token t;
}
{/*@bgen(jjtree) RelationName */
    try {
/*@egen*/
    t = <IDENTIFIER_NAME>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
	node.relationName = t.image;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void ResolveExpression()       :
{}
{
    "RES(" ( "'" ResourceIdentifierPath() "'" | ResourceIdentifierId() ) ")"
}

void ResourceIdentifierId() :
{/*@bgen(jjtree) ResourceIdentifierId */
    ASTResourceIdentifierId jjtn000 = new ASTResourceIdentifierId(this, JJTRESOURCEIDENTIFIERID);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    ASTResourceIdentifierId node = (ASTResourceIdentifierId)jjtn000;
    Token t;
}
{/*@bgen(jjtree) ResourceIdentifierId */
    try {
/*@egen*/
    t = <IDENTIFIER_ID>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
	node.identifier = t.image;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ResourceIdentifierPath() :
{/*@bgen(jjtree) ResourceIdentifierPath */
    ASTResourceIdentifierPath jjtn000 = new ASTResourceIdentifierPath(this, JJTRESOURCEIDENTIFIERPATH);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    ASTResourceIdentifierPath node = (ASTResourceIdentifierPath)jjtn000;
    Token t;
}
{/*@bgen(jjtree) ResourceIdentifierPath */
    try {
/*@egen*/
    t = <IDENTIFIER_PATH>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
	node.identifier = t.image;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
